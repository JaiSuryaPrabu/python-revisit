# Advanced Topics

## Lambda

### History
* Lambda functions came from **lambda calculus**
* It can *abstract* completely
* **Lambda calculus** is **Turing complete**

### Examples
Basic representation of a `function` in python
``` py linenums="1"
def number(x):
    return x
```
`number()` accepts `x` value and returns it.

By using `lambda` we can:
``` py linenums="1"
lambda number x : x
```

Syntax for the lambda function:
`lambda <function_name> <arguments> : <function_code>`

The lambda functions can be named to a `variable`
``` py linenums="1"
lambda_function = lambda number x : x
a = lambda_function(5)  # a contains value of 5
```

The lambda function with **multiple arguments**
``` py linenums="1"
lambda_function = lambda numbers a,b,c : a+b+c
sum_of = lambda_function(4,3,2) # sum_of has value of 9
``` 

`lambda` function is used as **higher order function**
``` py linenums="1"
higher_order_function = lambda x,lower_order : x + lower_order(x)
sum_of_x_and_x = higher_order_function(5, lambda x : x) # 10
sum_of_x_and_x_square = higher_order_function(5, lambda x: x*x) # 30
```

### Subtle Difference
> These are the **differences** between normal function and the lambda functions

#### Bytecode
> python's `dis` module is used to expose the functions to analyse **python bytecode** generated by python compiler

To check the bytecode of **normal** function
``` py linenums="1"
import dis
subtract = lambda x,y : x-y
dis.dis(subtract)
```

To check the bytecode of **lambda** function
``` py linenums="1"
import dis
def subtract(x,y): return x-y
dis.dis(subtract)
```

#### Traceback
The `Traceback` of an exception provides the name of the normal function but not in the **lambda** function

#### Syntax
* The `lambda` function doesn't allows any statements like return,pass,assert,raise
* It accepts only single expression 
* Adding a type annotation in `lambda` function results in SyntaxError

#### Arguments
* It supports:
    * **Positional** arguents
        ``` py
        (lambda x,y,z : x + y + z)(1,2,3)```
    * **Named** Arguments
        ``` py
        (lambda x,y,z=3 : x + y + z)(1,2)```
    * Variable **list** of arguments
        ```py 
        (lambda *args : sum(args))(1,2,3)```
    * Variable list of **keywords** arguments
        ```py 
        (lambda **kwargs : sum(kwargs.values()))(1,2,3)```
    * **Keywords** only arguments
        ```py
        (lambda x,y,z : x + y + z)(z=1,y=2,x=3)```

#### Decorators
* A `decorator` is a normal function that describes another function
* For example:
    ``` py linenums="1"
        # decorator function
        def about(function):
            def wrap(*args):
                print(f"The name of the function is {function.__name__}")
                return function(args)
            return wrap

        @about
        def func(x):
            print(f"The argument is {x}")

        func("Hello world")
    ```
    * The following is the output:
        ```
        The name of the function is func
        The argument is ('Hello world',)
        ```

* To apply decorator for lambda function,
    ``` py linenums="1"
        # the decorator
        def about_args(function):
            def wrap(*args,**kwargs):
                print(f"The function name is `{function.__name__}`")
                print(f"The arguments are : {args}")
                print(f"The Keyword arguments are : {kwargs}")
            return wrap

        # normal function
        @about_args
        def func(x):
            return x ** 2
        # function call with args
        func(3)
        # function call with keywords
        func(x=3)

        # lambda function
        print((about_args(lambda x: x ** 2)(x=3)))
    ```
    * The output is :
        ```
        The function name is `func`
        The arguments are : (3,)
        The Keyword arguments are : {}
        The function name is `func`
        The arguments are : ()
        The Keyword arguments are : {'x': 3}
        The function name is `<lambda>`
        The arguments are : ()
        The Keyword arguments are : {'x': 4}
        None
        ```
* The decorator can be used with the `map()` function:
    ```py 
    list(map(about_args(lambda x: x+2),range(3)))
    ```
### Do not
* Raise an exception in lambda function
* Make complex **lambda** functions
* Add **lambda** functions in a `class`

### Appropriate use of *lambda*
Lambda is used with the :
* `map()`,
* `filter()`,
* `functools.reduce()`

## Decorators

> `Decorators` are a function that defines another function
### Basic Syntax
The **decorator** part :
``` py linenums="1"
def decorator(function_name):
    # the wrapper part
    def wrapper(*args,*kwargs):
        # decorate of the function_name
        result = function_name(*args,**kwargs)
        return result
    return wrapper
```
The **normal function** part :
``` py linenums="1"
@decorator
def function():
    # sample code
    pass
```

## Use case
1. Used in class methods.
2. Used to add more flexiblity to function.
3. Can be used for the entire class too.

# Iterators and Iterables
> The main difference between iterators and iterables is that iterator has `next()` method but iterables doesn't contains it
## Iterators
1. The basic syntax
``` py linenums="1"
class iterator:

    # constructor
    def __init__(self,sequence):
        self.sequence = sequence
        self.index = 0

    # iter() method
    def __iter__(self):
        return iterator(self)

    # iter() method needs next() method for iterators
    def __next__(self):
        length = len(self.sequence)
        # logic of each element in the iterables
        if (self.index < length):
            value = self.sequence[self.index]
            self.index += 1
            return value
        else:
            # Stop Iteration is used to handle the inf loop
            raise StopIteration
```
2. Using `Iterators()` class from `collections.abc`
``` py linenums="1"
from collections.abc import Iterators

class iterator:
    
    # constructor
    def __init__(self,sequence):
        self.sequence = sequence
        self.index = 0
    
    # there is no need of iter() method

    def __next__(self):
        length = len(self.sequence)
        if self.index < length:
            value = self.sequence[self.index]
            self.index += 1
            return value
        else:
            raise StopIteration
```

## Iterables
1. Basic syntax
``` py linenums="1"
# code to be implemented
```

## Generators
> `Generators` are functions that produce iterators using `yield` statement

Basic syntax
``` py linenums="1"
def generators(sequence):
    for element in sequence:
        yield element

for i in generators([1,2,3,4]):
    print(i,end="\t")
```
